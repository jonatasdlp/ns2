<?xml version="1.0" encoding="UTF-8" ?>

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

	<xsl:output method="text" omit-xml-declaration="yes" indent="yes"/>

	<xsl:variable name="pi" select="3.14159265359"/>
  
	<xsl:template match="/simulation">
	
		# Generated by MannaSim
		# http://www.mannasim.dcc.ufmg.br/
		
		puts "Initializing MannaSim Script..."

		#Consumo de energia do sensor node - Dados do Mica Motes
		set mica(sensing_power) 0.015 ;# i = 5mA, V = 3 --> P = ixV = 15 mW = 0.015 W
		set mica(processing_power) 0.024 ;# i = 8mA, V = 3 --> P = ixV = 24 mW = 0.024 W
		set mica(instructions_per_second) 8000000 ;# Atmel 128L 8MHZ --> 8MIPS
		
		#Consumo de energia do sensor node - Dados do WINS
		set wins(sensing_power) 0.064 ;# 64 mW = 0.064 W
		set wins(processing_power) 0.360 ;# 360 mW = 0.360 W
		set wins(instructions_per_second) 150000000 ;# Intel StrongArm 1100 133 MHZ --> 150 MIPS
		
		#Seta valores para consumo de energia com o radio
		set mica(consumo_transmissao) 0.036 ;#i = 12mA, V = 3 --> P = ixV = 36mW = 0.036W
		set mica(consumo_recepcao) 0.024 ;#i = 8mA, V = 3 --> P = ixV = 24mW = 0.024W
		
		set wins(consumo_transmissao)	3.75 ;# 3.75 250m, 0.6 600 mW - 100m
		set wins(consumo_recepcao) 1.875 ;# 1.875 250m,  0.3 300 mW
		
		#seta a taxa de transmissao
		#Phy/WirelessPhy set  bandwidth_
		set mica(taxa_transmissao) 28.8*10e3 ;#28.8 kbps
		set wins(taxa_transmissao) 100*10e3 ;#100 kbps
		
		proc setup_mica2 { antenna range }  {
		
			puts "Setting up mica 2 mote with $antenna and range = $range"
		
			#Phy/WirelessPhy set CPThresh_ 10.0
			#Phy/WirelessPhy set CSThresh_ 1.559e-11
			#Phy/WirelessPhy set RXThresh_ 2.78869e-09	; # 100 meters
			#Phy/WirelessPhy set RXThresh_ 1.11548e-08	; # 50 meters
			#Phy/WirelessPhy set Rb_ 2*1e6
			
			Phy/WirelessPhy set Pt_ 0.281838
			Phy/WirelessPhy set freq_ 2.4e09
			Phy/WirelessPhy set L_ 1.0
			Phy/WirelessPhy set lambda_ 0.125
			Phy/WirelessPhy set RXThresh_ [TwoRay 0.281838 [$antenna set Gt_] [$antenna set Gr_] 0.8 0.8 1.0 $range 0.125]
			Phy/WirelessPhy set bandwidth_ 28.8*10e3 		;#28.8 kbps
			
			Node/MobileNode/SensorNode set sensingPower_ 0.015
			Node/MobileNode/SensorNode set processingPower 0.024
			Node/MobileNode/SensorNode set instructionsPerSecond_ 8000000

		}
		
		##########################################
		# CONSTANTES
		#########################################
		# Continuo: 0
		# Programada: 1
		# Sob Demanda: 2
		########################################
		
		proc create_common_app {destination_id disseminating_type disseminating_interval} {
		  global val
		  if { $val(commonApp) == "Application/SensorBaseApp/CommonNodeApp/LeachApp" } {
		  	  if { $val(n_ch) == 0 } {
		  	  	   puts "NO CLUSTER HEADS HAS BEEN DEFINED! Assuming 20% of common nodes."
		  	  	   set val(n_ch) [expr int($val(n_common) * 2 / 10)]
		  	  }
		  	  set app_ [new $val(commonApp) $val(nn) $val(n_ch) [expr sqrt($val(x) * $val(x) + $val(y) * $val(y))]]
		  } else {
			  set app_ [new $val(commonApp)]
			  $app_ set destination_id_ $destination_id
		  }
		  $app_ set disseminating_type_ $disseminating_type
		  $app_ set disseminating_interval_ $disseminating_interval
		  return $app_
		}
		
		set val(commonApp) "Application/SensorBaseApp/CommonNodeApp"
		set val(chApp)     "Application/SensorBaseApp/ClusterHeadApp"
		set val(apApp)	   "Application/AccessPointApp"
		
		proc create_cluster_head_app {destination_id disseminating_type disseminating_interval} {
		  global val
		  set app_ [new $val(chApp)]
		  $app_ set destination_id_ $destination_id
		  $app_ set disseminating_type_ $disseminating_type
		  $app_ set disseminating_interval_ $disseminating_interval
		  return $app_
		}
		
		proc create_access_point_app {outside_network} {
		  global val
		  set app_ [new $val(apApp)]
		  $app_ set outside_network_ $outside_network
		  return $app_
		}
		
		proc create_temp_data_generator {sensing_interval sensing_type avg_measure std_deviation maximumTemperatureAllowedValue} {
		  set temp_gen_ [new DataGenerator/TemperatureDataGenerator]
		  $temp_gen_ set sensing_interval_ $sensing_interval
		  $temp_gen_ set sensing_type_ $sensing_type
		  $temp_gen_ set avg_measure $avg_measure
		  $temp_gen_ set std_deviation $std_deviation
		  $temp_gen_ set maximumTemperatureAllowedValue_ $maximumTemperatureAllowedValue
		  return $temp_gen_
		}

		proc create_data_generator {generator sensing_interval sensing_type avg_measure std_deviation maximumTemperatureAllowedValue} {
		  set temp_gen_ [new DataGenerator/$generator]
		  $temp_gen_ set sensing_interval_ $sensing_interval
		  
		  if {$sensing_type=="continuous"} {
			  $temp_gen_ set sensing_type_ 0
		  } elseif {$sensing_type=="programmed"} {
			  $temp_gen_ set sensing_type_ 1
		  } elseif {$sensing_type=="on demand"} {
			  $temp_gen_ set sensing_type_ 2
		  } else {		  
			  $temp_gen_ set sensing_type_ $sensing_type
		  }
		  $temp_gen_ set avg_measure $avg_measure
		  $temp_gen_ set std_deviation $std_deviation
		  $temp_gen_ set maximumTemperatureAllowedValue_ $maximumTemperatureAllowedValue
		  return $temp_gen_
		}
		
		proc create_common_node { iniEnergy x y z father_addr start stop } {
			global val ns_ node_ topo udp_ app_ gen_ contador_nodos rng trace
		
			if { [llength $start] == 0 }  {
				set start [expr $val(start) + [$rng uniform 0 1]]
				set stop $val(stop)
			}
		
			$ns_ node-config -sensorNode ON \
			-adhocRouting $val(rp) \
			-llType $val(ll) \
			-macType $val(mac) \
			-ifqType $val(ifq) \
			-ifqLen $val(ifqlen) \
			-antType $val(antenna) \
			-propType $val(prop) \
			-energyModel $val(en) \
			-phyType $val(netif) \
			-channelType $val(chan) \
			-topoInstance $topo \
			-agentTrace $trace(agent) \
			-routerTrace $trace(router) \
			-macTrace $trace(mac) \
			-rxPower 0.024 \
			-txPower 0.036 \
			-initialEnergy $iniEnergy \
			-movementTrace $trace(movement)
			
			set node_($contador_nodos) [$ns_ node]
			$node_($contador_nodos) random-motion 0
		
		#	set x [$rng uniform 0.0 $val(x)]
		#	set y [$rng uniform 0.0 $val(y)]
		
#			set bla [expr int(sqrt($val(nn)))]
#			set x [expr (($contador_nodos) % $bla) * $val(x) / ($bla - 1)]
#			set y [expr (($contador_nodos) / $bla) * $val(y) / ($bla - 1)]

			$node_($contador_nodos) set X_ $x
			$node_($contador_nodos) set Y_ $y
			$node_($contador_nodos) set Z_ $z

			puts "* Node [$node_($contador_nodos) node-addr] = $contador_nodos created in ($x, $y, $z)"
		
			set app_($contador_nodos) [create_common_app $father_addr $val(disseminating_type) $val(disseminating_interval)]

			if { $val(leach) == 1 } {
			  set agent [new Agent/RCAgent]
			  
			  $agent set sport_ 0
			  $agent set dport_ 0
			
			  $node_($contador_nodos) attach $agent 0
			  $app_($contador_nodos) attach-agent $agent
			 
			  $agent add-ll [$node_($contador_nodos) set ll_(0)] [$node_($contador_nodos) set mac_(0)]
			} else {
				set udp_($contador_nodos) [new Agent/UDP]
				$node_($contador_nodos) attach $udp_($contador_nodos) $val(port)
			}
			$node_($contador_nodos) add-app $app_($contador_nodos)
		
			set processing_($contador_nodos) [new $val(processing)]
		
			$app_($contador_nodos) node $node_($contador_nodos)

			if { $val(leach) != 1 } {
				$app_($contador_nodos) attach-agent $udp_($contador_nodos)
			}
		
			$app_($contador_nodos) attach-processing $processing_($contador_nodos)
			$processing_($contador_nodos) node $node_($contador_nodos)
		
			for { set i 0 } { $i &lt; [llength $start] } { incr i } {
				$ns_ at $start "$app_($contador_nodos) start"
			}
			
			for { set i 0 } { $i &lt; [llength $stop] } { incr i } {
				$ns_ at $stop "$app_($contador_nodos) stop"
			}
		
		#[create_temp_data_generator  5.0 0 27.0 10.0 50]
			set gen_($contador_nodos) $val(data_generator)
				
			$app_($contador_nodos) attach_data_generator $gen_($contador_nodos)
		
			incr contador_nodos
		
		}

		proc create_cluster_head_node { iniEnergy x y z father_addr start stop } {
		
			global val ns_ node_ topo udp_ app_ gen_ contador_nodos rng trace
		
			if { [llength $start] == 0 }  {
				set start [expr $val(start) + [$rng uniform 0 1]]
				set stop $val(stop)
			}
		
			$ns_ node-config -sensorNode ON \
			-adhocRouting $val(rp) \
			-llType $val(ll) \
			-macType $val(mac) \
			-ifqType $val(ifq) \
			-ifqLen $val(ifqlen) \
			-antType $val(antenna) \
			-propType $val(prop) \
			-energyModel $val(en) \
			-phyType $val(netif) \
			-channelType $val(chan) \
			-topoInstance $topo \
			 -agentTrace $trace(agent) \
			-routerTrace $trace(router) \
			-macTrace $trace(mac) \
			-rxPower 0.024 \
			-txPower 0.036 \
			-initialEnergy $iniEnergy \
			-movementTrace $trace(movement)
			
			set node_($contador_nodos) [$ns_ node]
			$node_($contador_nodos) random-motion 0
		
		#	set x [$rng uniform 0.0 $val(x)]
		#	set y [$rng uniform 0.0 $val(y)]
		
#			set bla [expr int(sqrt($val(nn)))]
#			set x [expr (($contador_nodos) % $bla) * $val(x) / ($bla - 1)]
#			set y [expr (($contador_nodos) / $bla) * $val(y) / ($bla - 1)]

			$node_($contador_nodos) set X_ $x
			$node_($contador_nodos) set Y_ $y
			$node_($contador_nodos) set Z_ $z

			puts "* Cluster head [$node_($contador_nodos) node-addr] = $contador_nodos created in ($x, $y, $z)"
		
			set udp_($contador_nodos) [new Agent/UDP]
		
			set app_($contador_nodos) [create_cluster_head_app $father_addr $val(disseminating_type) $val(disseminating_interval)]
			
			$node_($contador_nodos) attach $udp_($contador_nodos) $val(port)
			$node_($contador_nodos) add-app $app_($contador_nodos)
		
#CN#		set processing_($contador_nodos) [new $val(processing)]
		
			$app_($contador_nodos) node $node_($contador_nodos)
			$app_($contador_nodos) attach-agent $udp_($contador_nodos)
		
#CN#		$app_($contador_nodos) attach-processing $processing_($contador_nodos)
			$processing_($contador_nodos) node $node_($contador_nodos)
		
			for { set i 0 } { $i &lt; [llength $start] } { incr i } {
				$ns_ at $start "$app_($contador_nodos) start"
			}
			
			for { set i 0 } { $i &lt; [llength $stop] } { incr i } {
				$ns_ at $stop "$app_($contador_nodos) stop"
			}
		
#CN#		set gen_($contador_nodos) $val(data_generator)
#CN#		$app_($contador_nodos) attach_data_generator $gen_($contador_nodos)
		
			incr contador_nodos
		
		}
		
		proc create_access_point { iniEnergy x y z start stop} {
			global ns_ val node_ app_ udp_ contador_nodos topo trace rng
			
			if { [llength $start] == 0 }  {
				set start [expr $val(start) + [$rng uniform 0 1]]
				set stop $val(stop)
			}
			
			$ns_ node-config -sensorNode ON \
			-adhocRouting $val(rp) \
			-llType $val(ll) \
			-macType $val(mac) \
			-ifqType $val(ifq) \
			-ifqLen $val(ifqlen) \
			-antType $val(antenna) \
			-propType $val(prop) \
			-energyModel $val(en) \
			-phyType $val(netif) \
			-channelType $val(chan) \
			-topoInstance $topo \
			 -agentTrace $trace(agent) \
			-routerTrace $trace(router) \
			-macTrace $trace(mac) \
			-rxPower 0.5 \
			-txPower 0.5 \
			-initialEnergy $iniEnergy \
			-movementTrace $trace(movement)

			set node_($contador_nodos) [$ns_ node]
			$node_($contador_nodos) random-motion 0
			set app_($contador_nodos) [create_access_point_app [$node_(0) node-addr]]
						
			if { $val(leach) == 1 } {
			  set agent [new Agent/RCAgent/LeachAgent]
			  
			  $agent set sport_ 0
			  $agent set dport_ 0
			
			  $node_($contador_nodos) attach $agent 0
			  $app_($contador_nodos) attach-agent $agent
			 
			  $agent add-ll [$node_($contador_nodos) set ll_(0)] [$node_($contador_nodos) set mac_(0)]
			} else {
			  set  udp_($contador_nodos) [new Agent/UDP]
			  $node_($contador_nodos) attach $udp_($contador_nodos) $val(port)
			  $app_($contador_nodos) attach-agent $udp_($contador_nodos)
			}
			$node_($contador_nodos) set X_ $x
			$node_($contador_nodos) set Y_ $y
			$node_($contador_nodos) set Z_ $z

			puts "* Access point [$node_($contador_nodos) node-addr] = $contador_nodos created in ($x, $y, $z)"
			
			for { set i 0 } { $i &lt; [llength $start] } { incr i } {
				$ns_ at $start "$app_($contador_nodos) start"
			}
			
			for { set i 0 } { $i &lt; [llength $stop] } { incr i } {
				$ns_ at $stop "$app_($contador_nodos) stop"
			}

			incr contador_nodos
		
		}
		
		###
		# Grid distribution.
		
		proc get_next_x {} {
		
			global val
			
			set aux [expr int(sqrt($val(nn)))]
			
			return [expr (($contador_nodos) % $aux) * $val(x) / ($aux - 1)]
			
		}
		
		proc get_next_y {} {
		
			global val

			set aux [expr int(sqrt($val(nn)))]

			return [expr (($contador_nodos) / $aux) * $val(y) / ($aux - 1)]
			
		}
		
		####
		# Calculating the receiving threshold (RXThresh_ for Phy/Wireless)
		# Wei Ye, weiye@isi.edu, 2000
		
		proc Friis { Pt Gt Gr lambda L d} {
		  set M [expr $lambda / (4 * <xsl:value-of select="$pi"/> * $d)]
		  return [expr ($Pt * $Gt * $Gr * ($M * $M)) / $L]
		}
		
		proc TwoRay { Pt Gt Gr ht hr L d lambda } {
		        set crossover_dist [expr (4 * <xsl:value-of select="$pi"/> * $ht * $hr) / $lambda]
		
		        if { $d &lt; $crossover_dist } {
		                return [Friis $Pt $Gt $Gr $lambda $L $d]
		        } else {
		                return [expr $Pt * $Gt * $Gr * ($hr * $hr * $ht * $ht) / ($d * $d * $d * $d * $L)]
		       }
		}
		
		###

		proc set_default_settings {} {
		
			global val

		<xsl:if test="count(defaultNetwork)=1">
			####
			# Default network settings
			
			<xsl:choose>
				<xsl:when test="count(defaultNetwork/omniAntenna)=1">
					set val(antenna) "Antenna/OmniAntenna"
					Antenna/OmniAntenna set X_ <xsl:value-of select="defaultNetwork/omniAntenna/@x"/>
					Antenna/OmniAntenna set Y_ <xsl:value-of select="defaultNetwork/omniAntenna/@y"/>
					Antenna/OmniAntenna set Z_ <xsl:value-of select="defaultNetwork/omniAntenna/@z"/>
					Antenna/OmniAntenna set Gt_ <xsl:value-of select="defaultNetwork/omniAntenna/@gt"/>
					Antenna/OmniAntenna set Gr_ <xsl:value-of select="defaultNetwork/omniAntenna/@gr"/>
				</xsl:when>
				<xsl:when test="count(defaultNetwork/antenna)=1">
					set val(antenna) "<xsl:value-of select="defaultNetwork/antenna/@name"/>"
					<xsl:value-of select="defaultNetwork/antenna/@name"/> set X_ <xsl:value-of select="defaultNetwork/antenna/@x"/> ;
					<xsl:value-of select="defaultNetwork/antenna/@name"/> set Y_ <xsl:value-of select="defaultNetwork/antenna/@y"/> ;
					<xsl:value-of select="defaultNetwork/antenna/@name"/> set Z_ <xsl:value-of select="defaultNetwork/antenna/@z"/> ;
					<xsl:value-of select="defaultNetwork/antenna/@name"/> set Gt_ <xsl:value-of select="defaultNetwork/antenna/@gt"/> ;
					<xsl:value-of select="defaultNetwork/antenna/@name"/> set Gr_ <xsl:value-of select="defaultNetwork/antenna/@gr"/> ;
				</xsl:when>
				<xsl:otherwise>
					# Using default antenna settings
					set val(antenna) "Antenna/OmniAntenna"
					Antenna/OmniAntenna set X_ 0
					Antenna/OmniAntenna set Y_ 0
					Antenna/OmniAntenna set Z_ 1.5
					Antenna/OmniAntenna set Gt_ 1.0
					Antenna/OmniAntenna set Gr_ 1.0
				</xsl:otherwise>
			</xsl:choose> 
			###
			
			 &#10;
			
			<xsl:choose>
				<xsl:when test="defaultNetwork/wirelessPhy/@profile='mica2'">
					# Using Mica 2 Mote settings
					
					<xsl:choose>
						<xsl:when test="count(defaultNetwork/WirelessPhy/range)=0">
							set val(range) 100
						</xsl:when>
						<xsl:otherwise>
							set val(range) <xsl:value-of select="defaultNetwork/WirelessPhy/range"/>
						</xsl:otherwise>
					</xsl:choose>
					
					setup_mica2 $val(antenna) $val(range)
				</xsl:when>
				<xsl:otherwise>
					# Initialize the SharedMedia interface with parameters to make
					# it work like the 914MHz Lucent WaveLAN DSSS radio interface
					
					Phy/WirelessPhy set CPThresh_ 10.0
					Phy/WirelessPhy set CSThresh_ 1.559e-11
					Phy/WirelessPhy set RXThresh_ 3.652e-10
					Phy/WirelessPhy set Rb_ 2*1e6
					Phy/WirelessPhy set Pt_ 0.2818
					Phy/WirelessPhy set freq_ 914e+6
					Phy/WirelessPhy set L_ 1.0
					
					Node/MobileNode/SensorNode set sensingPower_ 0.015
					Node/MobileNode/SensorNode set processingPower 0.024
					Node/MobileNode/SensorNode set instructionsPerSecond_ 8000000
				</xsl:otherwise>
			</xsl:choose>
			
			set val(bandwidth) [Phy/WirelessPhy set bandwidth_]
			
			<xsl:choose>
				<xsl:when test="count(defaultNetwork/mac)=0">
					set val(mac)	Mac/<xsl:value-of select="defaultNetwork/mac"/>
				</xsl:when>
				<xsl:otherwise>
					set val(mac)	Mac/802_11
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:choose>
				<xsl:when test="count(defaultNetwork/queue)=0">
					set val(ifq)	Queue/DropTail/PriQueue
				</xsl:when>
				<xsl:otherwise>
					set val(ifq)	<xsl:value-of select="defaultNetwork/queue"/>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:choose>
				<xsl:when test="count(defaultNetwork/queue/@length)=0">
					set val(ifqlen)	200
				</xsl:when>
				<xsl:otherwise>
					set val(ifqlen)	<xsl:value-of select="defaultNetwork/queue/@length"/>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:choose>
				<xsl:when test="count(defaultNetwork/linkLayer)=0">
					set val(ll)	LL
				</xsl:when>
				<xsl:otherwise>
					set val(ll)	<xsl:value-of select="defaultNetwork/linkLayer"/>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:choose>
				<xsl:when test="defaultNetwork/routingProtocol=LEACH">
					set val(rp)	"DumbAgent"
				</xsl:when>					
				<xsl:when test="count(defaultNetwork/routingProtocol)=1">
					set val(rp)	"<xsl:value-of select="defaultNetwork/routingProtocol"/>"
				</xsl:when>
			</xsl:choose>
		</xsl:if>

		<xsl:if test="count(defaultNetwork/dsSettings)=1">
			# Disseminating settings
			<xsl:variable name="type" select="defaultNetwork/@disseminatingType"/>
			<xsl:choose>
				<xsl:when test="$type='continuous'">
					set val(disseminating_type) 0		;# Continuous
				</xsl:when>
				<xsl:when test="$type='programmed'">
					set val(disseminating_type) 1		;# Programmed
				</xsl:when>
				<xsl:when test="$type='on demand'">
					set val(disseminating_type) 2		;# On demand
				</xsl:when>
				<xsl:otherwise>
					set val(disseminating_type) <xsl:value-of select="$type"/>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:if test="count(defaultNetwork/dsSettings/@interval)=1">
				set val(disseminating_interval)	<xsl:value-of select="defaultNetwork/dsSettings/@interval"/>
			</xsl:if>
		</xsl:if>
		
			# Configuration adjustment
		
			if { $val(rp) == "LEACH" } {
			
				set val(rp) DumbAgent
				set val(leach) 1
				
				if { $val(ll) != "RCALinkLayer" } {
					puts "LEACH requires RCALinkLayer! Forcing it!!!"					
					set val(ll)	RCALinkLayer
				}
				
				if { $val(netif) != "Phy/WirelessPhy/LeachWirelessPhy" } {
					puts "LEACH requires LeachWirelessPhy! Forcing it!!!"
					set val(netif) Phy/WirelessPhy/LeachWirelessPhy
				}
				
				if { $val(mac) != "Mac/Sensor" } {
					puts "LEACH requires Mac/Sensor! Forcing it!!!"
					set val(mac) Mac/Sensor
				}
				
				set val(port) 0
				
				Agent/RCAgent set sport_           $val(port)
				Agent/RCAgent set dport_           $val(port)
				Agent/RCAgent set packetMsg_       0
				Agent/RCAgent set distEst_         0
				Agent/RCAgent set packetSize_      0
	                                                                                                                 
				RCALinkLayer set delay_            25us
				RCALinkLayer set bandwidth_        [Phy/WirelessPhy set bandwidth_]
				RCALinkLayer set off_prune_        0
				RCALinkLayer set off_CtrMcast_     0
				RCALinkLayer set macDA_            0
				RCALinkLayer set debug_            0
			} else {
				set val(leach) 0
			}
			if { $val(rp) == "DIRECTED DIFFUSION" } {
				set val(rp) "Directed_Diffusion"
			}		
		}
		
		set val(father_addr) 0 
		set val(port)	2020
		
		set val(netif)	Phy/WirelessPhy
		
		set_default_settings
		
		# Global network settings
				
		set contador_nodos 0
		
		set val(chan)	Channel/WirelessChannel
		
		# Propagation
		<xsl:choose>
			<xsl:when test="count(defaultNetwork/propagation)=1">
				set val(prop)	<xsl:value-of select="defaultNetwork/propagation"/>
			</xsl:when>
			<xsl:otherwise>
				set val(prop)	Propagation/TwoRayGround
			</xsl:otherwise>
		</xsl:choose>
				
		# Energy model
		<xsl:choose>
			<xsl:when test="count(defaultNetwork/energyModel)=1">
				set val(en)	<xsl:value-of select="defaultNetwork/energyModel"/>
			</xsl:when>
			<xsl:otherwise>
				set val(en)	EnergyModel/Battery
			</xsl:otherwise>
		</xsl:choose>
				
		# Nodes
		set val(n_pas)	<xsl:value-of select="sum(accessPoint/@times)"/>
		set val(n_common) <xsl:value-of select="sum(commonNode/@times)"/>
		set val(n_ch) <xsl:value-of select="sum(clusterHead/@times)"/>
		set val(nn)	[expr $val(n_pas) + $val(n_common) + $val(n_ch)]
		
		puts "\nNodes count:"
		puts " - $val(n_pas) access points"
		puts " - $val(n_common) common nodes"
		puts " - $val(n_ch) cluster heads"
		puts " - $val(nn) nodes"
		puts " - $val(rp) routing protocol"
		puts " - $val(ll) link layer"
		puts " - $val(netif) network interface"
		
		# Scenario size
		set val(x)	<xsl:value-of select="scenario/@width"/>
		set val(y)	<xsl:value-of select="scenario/@height"/>
		
		puts "\nScenario size: $val(x) x $val(y)"

		set val(start)	0.0
		set val(stop)	[expr $val(start) + <xsl:value-of select="time"/>]

		set ns_		[new Simulator]
		
		<xsl:if test="count(trace)=1">
			# Trace
			puts "\nUsing <xsl:value-of select="trace"/> as trace file"
			set traceFile	[open <xsl:value-of select="trace"/> w]
			$ns_ trace-all $traceFile
			$ns_ use-newtrace
			
			<xsl:choose>
				<xsl:when test="trace/@mac='false'">
					set trace(mac) OFF
				</xsl:when>
				<xsl:otherwise>
					set trace(mac) ON
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="trace/@router='false'">
					set trace(router) OFF
				</xsl:when>
				<xsl:otherwise>
					set trace(router) ON
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="trace/@agent='false'">
					set trace(agent) OFF
				</xsl:when>
				<xsl:otherwise>
					set trace(agent) ON
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="trace/@movement='false'">
					set trace(movement) OFF
				</xsl:when>
				<xsl:otherwise>
					set trace(movement) ON
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
		
		set topo	[new Topography]
		$topo load_flatgrid $val(x) $val(y)
		create-god $val(nn)
		set rng [new RNG]
		$rng seed [clock seconds]

#-------------------------------------------------------------------------------------------

		<xsl:apply-templates select="accessPoint"/>	
		<xsl:apply-templates select="commonNode"/>
  
		$ns_ at [expr $val(stop)] "flush stdout"
		$ns_ at [expr $val(stop)+0.0001] "finish"

		proc finish {} {
		    global ns_ traceFile namtrace tempoInicio val
		
		    $ns_ flush-trace
		#    close $namtrace
		
		    $ns_ halt
		    $ns_ flush-trace
		    $ns_ nam-end-wireless $val(stop)
		
		    close $traceFile
		
		    flush stdout
		
		    exit 0
		}

		puts "Starting Simulation..."
		$ns_ run
		
	</xsl:template>

	<xsl:template match="accessPoint">

		# Creating an access point
		puts "Creating an access point..."
		
		set_default_settings
		
		<xsl:apply-templates select="network/*"/>
		
		<xsl:choose>
			<xsl:when test="count(position)=1">
				set local(x) <xsl:value-of select="position/@x"/>
				set local(y) <xsl:value-of select="position/@y"/>
				set local(z) <xsl:value-of select="position/@z"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="distribution='grid'">
						set local(x) [get_next_x]
						set local(y) [get_next_y]
						set local(z) 0.0
					</xsl:when>
					<xsl:otherwise>
						set local(x) [$rng uniform 0.0 $val(x)]
						set local(y) [$rng uniform 0.0 $val(y)]
						set local(z) 0.0
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		
		set local(start) ""
		set local(stop) ""
		
		<xsl:apply-templates select="start"/>
		<xsl:apply-templates select="stop"/>
		
		<xsl:choose>
			<xsl:when test="count(energy)=1">
				set local(energy) <xsl:value-of select="energy"/>
			</xsl:when>
			<xsl:otherwise>
				set local(energy) 10000000000
			</xsl:otherwise>
		</xsl:choose>
		
		set val(apApp) <xsl:value-of select="application"/>
		
		create_access_point $local(energy) $local(x) $local(y) $local(z) $local(start) $local(stop)

	</xsl:template>

	<xsl:template match="commonNode">

		# Creating common node
		puts "Creating common node..."
		
		set_default_settings
		
		<xsl:apply-templates select="network/*"/>
		
		set local(start) ""
		set local(stop) ""
		
		<xsl:apply-templates select="start"/>
		<xsl:apply-templates select="stop"/>
		
		<xsl:choose>
			<xsl:when test="count(energy)=1">
				set local(energy) <xsl:value-of select="energy"/>
			</xsl:when>
			<xsl:otherwise>
				set local(energy) 100
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:choose>
			<xsl:when test="count(father_addr)=1">
				set local(father_addr) <xsl:value-of select="father_addr"/>
			</xsl:when>
			<xsl:otherwise>
				set local(father_addr) $val(father_addr)
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:apply-templates select="processing"/>
		<xsl:apply-templates select="dataGenerator"/>

		<xsl:if test="@times &gt; 1">
		for { set common_node_i 0 } { $common_node_i &lt; <xsl:value-of select="@times"/> } { incr common_node_i } {
		</xsl:if>		

		<xsl:choose>
			<xsl:when test="count(position)=1">
				set local(x) <xsl:value-of select="@x"/>
				set local(y) <xsl:value-of select="@y"/>
				set local(z) <xsl:value-of select="@z"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="distribution='grid'">
						set local(x) [get_next_x]
						set local(y) [get_next_y]
						set local(z) 0.0
					</xsl:when>
					<xsl:otherwise>
						set local(x) [$rng uniform 0.0 $val(x)]
						set local(y) [$rng uniform 0.0 $val(y)]
						set local(z) 0.0
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		
		set val(commonApp) <xsl:value-of select="application"/>
		
		create_common_node $local(energy) $local(x) $local(y) $local(z) $local(father_addr) $local(start) $local(stop)

		<xsl:if test="@times &gt; 1">
		}
		</xsl:if>

	</xsl:template>

	<xsl:template match="clusterHead">

		# Creating common node
		puts "Creating cluster head node..."
		
		set_default_settings
		
		<xsl:apply-templates select="network/*"/>
		
		set local(start) ""
		set local(stop) ""
		
		<xsl:apply-templates select="start"/>
		<xsl:apply-templates select="stop"/>
		
		<xsl:choose>
			<xsl:when test="count(energy)=1">
				set local(energy) <xsl:value-of select="energy"/>
			</xsl:when>
			<xsl:otherwise>
				set local(energy) 100
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:choose>
			<xsl:when test="count(father_addr)=1">
				set local(father_addr) <xsl:value-of select="father_addr"/>
			</xsl:when>
			<xsl:otherwise>
				set local(father_addr) $val(father_addr)
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:apply-templates select="processing"/>
		<xsl:apply-templates select="dataGenerator"/>

		<xsl:if test="@times &gt; 1">
		for { set common_node_i 0 } { $common_node_i &lt; <xsl:value-of select="@times"/> } { incr common_node_i } {
		</xsl:if>		

		<xsl:choose>
			<xsl:when test="count(position)=1">
				set local(x) <xsl:value-of select="@x"/>
				set local(y) <xsl:value-of select="@y"/>
				set local(z) <xsl:value-of select="@z"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="distribution='grid'">
						set local(x) [get_next_x]
						set local(y) [get_next_y]
						set local(z) 0.0
					</xsl:when>
					<xsl:otherwise>
						set local(x) [$rng uniform 0.0 $val(x)]
						set local(y) [$rng uniform 0.0 $val(y)]
						set local(z) 0.0
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		
		set val(chApp) <xsl:value-of select="application"/>
		
		create_cluster_head_node $local(energy) $local(x) $local(y) $local(z) $local(father_addr) $local(start) $local(stop)

		<xsl:if test="@times &gt; 1">
		}
		</xsl:if>

	</xsl:template>
		
	<xsl:template match="network/omniAntenna">
		puts "Using omni antenna"
		set val(antenna) "Antenna/OmniAntenna"
		Antenna/OmniAntenna set X_ <xsl:value-of select="omniAntenna/@x"/> 
		Antenna/OmniAntenna set Y_ <xsl:value-of select="omniAntenna/@y"/> 
		Antenna/OmniAntenna set Z_ <xsl:value-of select="omniAntenna/@z"/> 
		Antenna/OmniAntenna set Gt_ <xsl:value-of select="omniAntenna/@gt"/> 
		Antenna/OmniAntenna set Gr_ <xsl:value-of select="omniAntenna/@gr"/> 
	</xsl:template>

	<xsl:template match="network/wirelessPhy">
		<xsl:if test="@profile='mica2'">
			# Using Mica 2 Mote settings
			
			puts "Using mica 2 mote settings"
			
			<xsl:choose>
				<xsl:when test="count(range)=0">
					set val(range) 100
				</xsl:when>
				<xsl:otherwise>
					set val(range) <xsl:value-of select="range"/>
				</xsl:otherwise>
			</xsl:choose>
			
			setup_mica2 $val(antenna) $val(range)
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="network/wirelessPhy/mac">
		set val(mac)	Mac/<xsl:value-of select="."/>
		puts "Using MAC $val(mac)"
	</xsl:template>
		
	<xsl:template match="network/wirelessPhy/queue">
		set val(ifq)	<xsl:value-of select="."/>
		puts "Using queue $val(ifq)"
		<xsl:if test="count(@length)=0">
			set val(ifqlen)	<xsl:value-of select="@length"/>
			puts "Using queue length $val(ifqlen)"
		</xsl:if>
	</xsl:template>
		
	<xsl:template match="network/wirelessPhy/linkLayer">
		set val(ll)	<xsl:value-of select="linkLayer"/>
		puts "Using link layer $val(ll)"
	</xsl:template>
	
	<xsl:template match="network/wirelessPhy/routingProtocol">
		set val(rp)	<xsl:value-of select="routingProtocol"/>
		puts "Using routing protocol $val(rp)"
	</xsl:template>

	<xsl:template match="network/disseminatingType">
		# Disseminating settings
		<xsl:choose>
			<xsl:when test=".='continuous'">
				set val(disseminating_type) 0		;# Continuous
				puts "Setting disseminating type to continuous"
			</xsl:when>
			<xsl:when test=".='programmed'">
				set val(disseminating_type) 1		;# Programmed
				puts "Setting disseminating type to programmed"
			</xsl:when>
			<xsl:when test=".='on demand'">
				set val(disseminating_type) 2		;# On demand
				puts "Setting disseminating type to on demand"
			</xsl:when>
			<xsl:otherwise>
				set val(disseminating_type) <xsl:value-of select="."/>
				puts "Setting disseminating type to custom: $val(disseminating_type)"
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:if test="count(@interval)=1">
			set val(disseminating_interval)	<xsl:value-of select="@interval"/>
			puts "Setting disseminating interval: $val(disseminating_interval)"
		</xsl:if>
	</xsl:template>
		
	<xsl:template match="start">
		lappend local(start) <xsl:value-of select="."/>
	</xsl:template>

	<xsl:template match="stop">
		lappend local(stop) <xsl:value-of select="."/>
	</xsl:template>
	
	<xsl:template match="processing">
		set val(processing) <xsl:value-of select="."/>
	</xsl:template>

	<xsl:template match="dataGenerator">
		set val(data_generator) "[create_data_generator {<xsl:value-of select="@type"/>} {<xsl:value-of select="sensingInterval"/>} {<xsl:value-of select="sensingType"/>} {<xsl:value-of select="avgMeasure"/>} {<xsl:value-of select="stdDeviation"/>} {<xsl:value-of select="max"/>}]"
	</xsl:template>
	
	<xsl:template match="temperatureGenerator">
		<xsl:choose>
			<xsl:when test="sensingType='continuous'">
				set val(data_generator) "[create_temp_data_generator <xsl:value-of select="sensingInterval"/> 0 <xsl:value-of select="avgMeasure"/> <xsl:value-of select="stdDeviation"/> <xsl:value-of select="max"/>]"
			</xsl:when>
			<xsl:when test=".='programmed'">
				set val(data_generator) "[create_temp_data_generator <xsl:value-of select="sensingInterval"/> 1 <xsl:value-of select="avgMeasure"/> <xsl:value-of select="stdDeviation"/> <xsl:value-of select="max"/>]"
			</xsl:when>
			<xsl:when test=".='on demand'">
				set val(data_generator) "[create_temp_data_generator <xsl:value-of select="sensingInterval"/> 2 <xsl:value-of select="avgMeasure"/> <xsl:value-of select="stdDeviation"/> <xsl:value-of select="max"/>]"
			</xsl:when>
			<xsl:otherwise>
				set val(data_generator) "[create_temp_data_generator <xsl:value-of select="sensingInterval"/> <xsl:value-of select="sensingType"/> <xsl:value-of select="avgMeasure"/> <xsl:value-of select="stdDeviation"/> <xsl:value-of select="max"/>]"
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
</xsl:stylesheet>
